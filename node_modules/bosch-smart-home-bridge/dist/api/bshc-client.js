"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var rxjs_1 = require("rxjs");
var abstract_bshc_client_1 = require("./abstract-bshc-client");
var operators_1 = require("rxjs/operators");
var bshb_error_1 = require("../error/bshb-error");
var bshb_error_type_1 = require("../error/bshb-error-type");
/**
 * This client contains some basic calls which are available to contact Bosch Smart Home Controller (BSHC)
 * the method {@link BshcClient#call} is not a predefined call and allows to specify it in more detail
 *
 * @author Christopher Holomek
 * @since 26.09.2019
 */
var BshcClient = /** @class */ (function (_super) {
    __extends(BshcClient, _super);
    /**
     * Create a new instance of the Bosch Smart Home Controller Client
     *
     * @param host
     *        host name / ip address of BSHC
     * @param certificateStorage
     *        instance of certificate storage
     * @param logger
     *        logger to use
     */
    function BshcClient(host, certificateStorage, logger) {
        var _this = _super.call(this, host, logger) || this;
        _this.certificateStorage = certificateStorage;
        return _this;
    }
    BshcClient.prototype.getOptions = function (bshbCallOptions) {
        if (bshbCallOptions) {
            return {
                certificateStorage: this.certificateStorage,
                bshbCallOptions: bshbCallOptions
            };
        }
        else {
            return {
                certificateStorage: this.certificateStorage
            };
        }
    };
    /**
     * Get information about BSHC
     * @param bshbCallOptions
     *        define custom headers, etc. Some values may be overwritten. E.g. host
     * @return bshb response object
     */
    BshcClient.prototype.getInformation = function (bshbCallOptions) {
        return this.simpleCall(BshcClient.PAIR_PORT, 'GET', "/" + BshcClient.PATH_PREFIX + "/information", null, this.getOptions(bshbCallOptions));
    };
    /**
     * Get all rooms stored
     * @param bshbCallOptions
     *        define custom headers, etc. Some values may be overwritten. E.g. host
     * @return bshb response object
     */
    BshcClient.prototype.getRooms = function (bshbCallOptions) {
        return this.simpleCall(BshcClient.COMMON_PORT, 'GET', "/" + BshcClient.PATH_PREFIX + "/rooms", null, this.getOptions(bshbCallOptions));
    };
    /**
     * Same as {@link BshcClient#getDevice()}
     * @param bshbCallOptions
     *        define custom headers, etc. Some values may be overwritten. E.g. host
     * @return bshb response object
     */
    BshcClient.prototype.getDevices = function (bshbCallOptions) {
        return this.getDevice(undefined, bshbCallOptions);
    };
    BshcClient.prototype.getDevice = function (deviceId, bshbCallOptions) {
        return this.simpleCall(BshcClient.COMMON_PORT, 'GET', "/" + BshcClient.PATH_PREFIX + "/devices/" + (deviceId ? deviceId : ""), null, this.getOptions(bshbCallOptions));
    };
    /**
     * Get all available service ids of a specified device
     * @param deviceId identifier of a device
     * @param bshbCallOptions
     *        define custom headers, etc. Some values may be overwritten. E.g. host
     * @return a string array which contains all service ids of a device
     */
    BshcClient.prototype.getDeviceServiceIds = function (deviceId, bshbCallOptions) {
        if (deviceId) {
            return this.getDeviceServices(deviceId).pipe(operators_1.map(function (services) {
                var result = [];
                services.parsedResponse.forEach(function (service) {
                    // although the library never cared about the response we need to do this here.
                    result.push(service.id);
                });
                return result;
            }));
        }
        else {
            return rxjs_1.of([]);
        }
    };
    /**
     * Get supported device types
     * @param bshbCallOptions
     *        define custom headers, etc. Some values may be overwritten. E.g. host
     * @return bshb response object
     */
    BshcClient.prototype.getSupportedDeviceTypes = function (bshbCallOptions) {
        return this.simpleCall(BshcClient.COMMON_PORT, 'GET', "/" + BshcClient.PATH_PREFIX + "/configuration/supportedDeviceTypes", null, this.getOptions(bshbCallOptions));
    };
    /**
     * Get services of all devices
     * @param bshbCallOptions
     *        define custom headers, etc. Some values may be overwritten. E.g. host
     * @return bshb response object
     */
    BshcClient.prototype.getDevicesServices = function (bshbCallOptions) {
        return this.getDeviceServices(undefined, undefined, bshbCallOptions);
    };
    BshcClient.prototype.getDeviceServices = function (deviceId, serviceId, bshbCallOptions) {
        var path = "/" + BshcClient.PATH_PREFIX + "/services";
        if (deviceId) {
            path = "/" + BshcClient.PATH_PREFIX + "/devices/" + deviceId + "/services/";
            if (serviceId && serviceId !== 'all') {
                path += serviceId;
            }
        }
        return this.simpleCall(BshcClient.COMMON_PORT, 'GET', path, null, this.getOptions(bshbCallOptions));
    };
    /**
     * Get all scenarios
     * @param bshbCallOptions
     *        define custom headers, etc. Some values may be overwritten. E.g. host
     * @return bshb response object
     */
    BshcClient.prototype.getScenarios = function (bshbCallOptions) {
        return this.simpleCall(BshcClient.COMMON_PORT, 'GET', "/" + BshcClient.PATH_PREFIX + "/scenarios", null, this.getOptions(bshbCallOptions));
    };
    /**
     * Trigger the specified scenario
     * @param scenarioId
     *        identifier of a scenario
     * @param bshbCallOptions
     *        define custom headers, etc. Some values may be overwritten. E.g. host
     * @return bshb response object
     */
    BshcClient.prototype.triggerScenario = function (scenarioId, bshbCallOptions) {
        return this.simpleCall(BshcClient.COMMON_PORT, 'POST', "/" + BshcClient.PATH_PREFIX + "/scenarios/" + scenarioId + "/triggers", null, this.getOptions(bshbCallOptions));
    };
    /**
     * Get alarm state
     * @param bshbCallOptions
     *        define custom headers, etc. Some values may be overwritten. E.g. host
     * @return bshb response object
     */
    BshcClient.prototype.getAlarmState = function (bshbCallOptions) {
        var path = '/devices/intrusionDetectionSystem/services/IntrusionDetectionControl/state';
        return this.simpleCall(BshcClient.COMMON_PORT, 'GET', "/" + BshcClient.PATH_PREFIX + path, null, this.getOptions(bshbCallOptions));
    };
    /**
     * Set alarm state
     * @param armed
     *        <code>true</code> if alarm should be armed. Otherwise <code>false</code>
     * @param bshbCallOptions
     *        define custom headers, etc. Some values may be overwritten. E.g. host
     * @return bshb response object
     */
    BshcClient.prototype.setAlarmState = function (armed, bshbCallOptions) {
        var value;
        if (armed) {
            value = '"SYSTEM_ARMED"';
        }
        else {
            value = '"SYSTEM_DISARMED"';
        }
        var data = "{\"@type\": \"intrusionDetectionControlState\",\"value\": " + value + "}";
        return this.putState('devices/intrusionDetectionSystem/services/IntrusionDetectionControl', data, bshbCallOptions);
    };
    /**
     * Get alarm state
     * @param bshbCallOptions
     *        define custom headers, etc. Some values may be overwritten. E.g. host
     * @return bshb response object
     */
    BshcClient.prototype.getPresenceSimulation = function (bshbCallOptions) {
        var path = '/devices/presenceSimulationService/services/PresenceSimulationConfiguration/state';
        return this.simpleCall(BshcClient.COMMON_PORT, 'GET', "/" + BshcClient.PATH_PREFIX + path, null, this.getOptions(bshbCallOptions));
    };
    /**
     * Set alarm state
     * @param enable
     *        <code>true</code> if presence is enabled. Otherwise <code>false</code>
     * @param bshbCallOptions
     *        define custom headers, etc. Some values may be overwritten. E.g. host
     * @return bshb response object
     */
    BshcClient.prototype.setPresenceSimulation = function (enable, bshbCallOptions) {
        var data = "{\"@type\": \"presenceSimulationConfigurationState\",\"enabled\": " + enable + "}";
        return this.putState('devices/presenceSimulationService/services/PresenceSimulationConfiguration', data, bshbCallOptions);
    };
    /**
     * Tell BSHC to set a new value for a specified state. Use the device service path to identify the state
     * @param path
     *        device service path to use
     * @param data
     *        data to send. Will be converted to json. It must contain @type otherwise BSHC will not understand the request
     *        (see https://apidocs.bosch-smarthome.com/local/).
     * @param bshbCallOptions
     *        define custom headers, etc. Some values may be overwritten. E.g. host
     * @return bshb response object
     */
    BshcClient.prototype.putState = function (path, data, bshbCallOptions) {
        return this.simpleCall(BshcClient.COMMON_PORT, 'PUT', "/" + BshcClient.PATH_PREFIX + "/" + path + "/state", data, this.getOptions(bshbCallOptions));
    };
    /**
     * Get all connected clients
     * @param bshbCallOptions
     *        define custom headers, etc. Some values may be overwritten. E.g. host
     * @return bshb response object
     */
    BshcClient.prototype.getClients = function (bshbCallOptions) {
        return this.simpleCall(BshcClient.COMMON_PORT, 'GET', "/" + BshcClient.PATH_PREFIX + "/clients", null, this.getOptions(bshbCallOptions));
    };
    /**
     * Get all messages
     * @param bshbCallOptions
     *        define custom headers, etc. Some values may be overwritten. E.g. host
     * @return bshb response object
     */
    BshcClient.prototype.getMessages = function (bshbCallOptions) {
        return this.simpleCall(BshcClient.COMMON_PORT, 'GET', "/" + BshcClient.PATH_PREFIX + "/messages", null, this.getOptions(bshbCallOptions));
    };
    /**
     * Delete all specified message ids
     * @param ids
     *        an array of identifier of messages
     * @param bshbCallOptions
     *        define custom headers, etc. Some values may be overwritten. E.g. host
     * @return bshb response object
     */
    BshcClient.prototype.deleteMessages = function (ids, bshbCallOptions) {
        return this.simpleCall(BshcClient.COMMON_PORT, 'POST', "/" + BshcClient.PATH_PREFIX + "/messages/batchDelete", ids, this.getOptions(bshbCallOptions));
    };
    /**
     * Get the specified message
     * @param id
     *        identifier of a message
     * @param bshbCallOptions
     *        define custom headers, etc. Some values may be overwritten. E.g. host
     * @return bshb response object
     */
    BshcClient.prototype.getMessage = function (id, bshbCallOptions) {
        return this.simpleCall(BshcClient.COMMON_PORT, 'GET', "/" + BshcClient.PATH_PREFIX + "/messages/" + id, null, this.getOptions(bshbCallOptions));
    };
    /**
     * Delete a specified message
     * @param id
     *        identifier of a message
     * @param bshbCallOptions
     *        define custom headers, etc. Some values may be overwritten. E.g. host
     * @return bshb response object
     */
    BshcClient.prototype.deleteMessage = function (id, bshbCallOptions) {
        return this.simpleCall(BshcClient.COMMON_PORT, 'DELETE', "/" + BshcClient.PATH_PREFIX + "/messages/" + id, null, this.getOptions(bshbCallOptions));
    };
    /**
     * Get status of windows/doors
     * @param bshbCallOptions
     */
    BshcClient.prototype.getOpenWindows = function (bshbCallOptions) {
        return this.simpleCall(BshcClient.COMMON_PORT, 'GET', "/" + BshcClient.PATH_PREFIX + "/doors-windows/openwindows", null, this.getOptions(bshbCallOptions));
    };
    /**
     * Subscribe to listen to notifications of bshc
     *
     * @return an object which contains 'result' which is the subscriptionId and 'jsonrpc' which is the json-rpc version
     */
    BshcClient.prototype.subscribe = function () {
        return this.call(BshcClient.COMMON_PORT, 'POST', '/remote/json-rpc', {
            'jsonrpc': '2.0',
            'method': 'RE/subscribe',
            'params': ['com/bosch/sh/remote/*', null] // we subscribe to all topics
        });
    };
    /**
     * Start long polling after subscription
     *
     * @param subscriptionId
     *        identifier from subscription request
     * @param timeout
     *        time (ms) for how long the request is kept open. Default is 30000 ms
     */
    BshcClient.prototype.longPolling = function (subscriptionId, timeout) {
        if (timeout === null || typeof timeout === 'undefined') {
            timeout = 30000;
        }
        return this.call(BshcClient.COMMON_PORT, 'POST', '/remote/json-rpc', {
            'jsonrpc': '2.0',
            'method': 'RE/longPoll',
            'params': [subscriptionId, timeout / 1000]
        }, {
            // We do that because node http does not recognize that bshc is gone.
            // Request would be stuck forever which we do not want
            // this is the only option I could find to get notified if no something went wrong during polling
            // 1s due to network delays.
            timeout: timeout + 1000
        }).pipe(operators_1.tap(function (response) {
            if (response && response.parsedResponse && response.parsedResponse.error) {
                throw new bshb_error_1.BshbError('error during polling: ' + response.parsedResponse.error, bshb_error_type_1.BshbErrorType.POLLING);
            }
        }));
    };
    /**
     * Stop subscription
     *
     * @param subscriptionId
     *        identifier from subscription request
     */
    BshcClient.prototype.unsubscribe = function (subscriptionId) {
        return this.call(BshcClient.COMMON_PORT, 'POST', '/remote/json-rpc', {
            'jsonrpc': '2.0',
            'method': 'RE/unsubscribe',
            'params': [subscriptionId]
        });
    };
    /**
     * Not defined call to BSHC in case something is missing here
     * @param port
     *        port to use
     * @param method
     *        HTTP method to use
     * @param path
     *        url path to use
     * @param data
     *        data to send. Will be converted to json. It must contain @type otherwise BSHC will not understand the request.
     * @param bshbCallOptions
     *        define custom headers, etc. Some values may be overwritten. E.g. host
     */
    BshcClient.prototype.call = function (port, method, path, data, bshbCallOptions) {
        var options = this.getOptions(bshbCallOptions);
        return this.simpleCall(port, method, path, data, options);
    };
    BshcClient.COMMON_PORT = 8444;
    BshcClient.PATH_PREFIX = 'smarthome';
    return BshcClient;
}(abstract_bshc_client_1.AbstractBshcClient));
exports.BshcClient = BshcClient;
