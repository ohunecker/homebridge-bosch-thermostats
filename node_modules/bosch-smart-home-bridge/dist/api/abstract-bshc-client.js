"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var rxjs_1 = require("rxjs");
var https = __importStar(require("https"));
var bshb_response_1 = require("../bshb-response");
var bshb_error_1 = require("../error/bshb-error");
var bshb_error_type_1 = require("../error/bshb-error-type");
var bshb_utils_1 = require("../bshb-utils");
/**
 * This class provides a simple call for all defined clients
 *
 * @author Christopher Holomek
 * @since 26.09.2019
 */
var AbstractBshcClient = /** @class */ (function () {
    /**
     * Needed parameters for a {@link AbstractBshcClient}
     *
     * @param host
     *        host name / ip address of BSHC
     * @param logger
     *        Logger to use
     */
    function AbstractBshcClient(host, logger) {
        this.host = host;
        this.logger = logger;
    }
    /**
     * A simple call to the Bosch Smart Home Controller (BSHC)
     * @param port
     *        port to use for the call
     * @param method
     *        HTTP method type
     * @param path
     *        path to use
     * @param data
     *        body of request. If not defined no content will be set
     * @param options
     *        a set of options to specify the call regarding security.
     */
    AbstractBshcClient.prototype.simpleCall = function (port, method, path, data, options) {
        var _this = this;
        var requestOptions = {};
        requestOptions.timeout = AbstractBshcClient.DEFAULT_TIMEOUT;
        requestOptions.hostname = this.host;
        requestOptions.port = port;
        requestOptions.path = path;
        requestOptions.method = method;
        requestOptions.rejectUnauthorized = true;
        requestOptions.checkServerIdentity = function (host) {
            // we cannot use tls.checkServerIdentity because it would fail altname check
            host = '' + host;
            if (host === _this.host) {
                return undefined;
            }
            else {
                throw new bshb_error_1.BshbError("Hostname verification failed. server=" + host + " expected=" + _this.host, bshb_error_type_1.BshbErrorType.ERROR);
            }
        };
        requestOptions.ca = bshb_utils_1.BshbUtils.getBoschSmartHomeControllerRootCa();
        if (!requestOptions.headers) {
            requestOptions.headers = {};
        }
        requestOptions.headers['Content-Type'] = 'application/json';
        requestOptions.headers['Accept'] = 'application/json';
        if (options && options.bshbCallOptions && options.bshbCallOptions) {
            Object.keys(options.bshbCallOptions).forEach(function (key) {
                requestOptions[key] = options.bshbCallOptions[key];
            });
        }
        if (options && options.certificateStorage) {
            requestOptions.key = options.certificateStorage.clientPrivateKey;
            requestOptions.cert = options.certificateStorage.clientCert;
        }
        if (options && options.systemPassword) {
            requestOptions.headers['Systempassword'] = Buffer.from(options.systemPassword).toString('base64');
        }
        this.logger.fine('requestOptions: ', requestOptions);
        var postData = undefined;
        if (data) {
            if (typeof data === 'string') {
                postData = data;
            }
            else {
                postData = JSON.stringify(data);
            }
            requestOptions.headers['Content-Length'] = postData.length;
        }
        this.logger.fine('');
        this.logger.fine('call:\n' + requestOptions.method + ' | ' + requestOptions.hostname + ':' + requestOptions.port + requestOptions.path);
        this.logger.fine('headers:\n', requestOptions.headers);
        this.logger.fine('body:\n', postData ? postData : '');
        this.logger.fine('');
        return new rxjs_1.Observable(function (observer) {
            var req = https.request(requestOptions, function (res) {
                _this.logger.fine('');
                _this.logger.fine('response information:');
                _this.logger.fine('status:', res.statusCode);
                _this.logger.fine('headers:', res.headers);
                var chunks = [];
                res.on('data', function (data) {
                    chunks.push(data);
                }).on('end', function () {
                    var dataString = undefined;
                    if (chunks.length > 0) {
                        var data_1 = Buffer.concat(chunks);
                        dataString = data_1.toString('utf-8');
                    }
                    _this.logger.fine('content: ', dataString);
                    _this.logger.fine('');
                    try {
                        var parsedData = undefined;
                        if (dataString) {
                            parsedData = JSON.parse(dataString);
                        }
                        observer.next(new bshb_response_1.BshbResponse(res, parsedData));
                    }
                    catch (e) {
                        observer.error(new bshb_error_1.BshbError('error during parsing response from BSHC:', bshb_error_type_1.BshbErrorType.PARSING, e));
                    }
                    finally {
                        observer.complete();
                    }
                }).on('error', function (err) {
                    _this.handleError(observer, bshb_error_type_1.BshbErrorType.ERROR, err);
                });
            });
            // error and socket handling
            req.on('error', function (err) {
                _this.handleError(observer, bshb_error_type_1.BshbErrorType.ERROR, err);
            }).on('abort', function () {
                _this.handleError(observer, bshb_error_type_1.BshbErrorType.ABORT, 'call to BSHC aborted by client');
            }).on('timeout', function () {
                _this.handleError(observer, bshb_error_type_1.BshbErrorType.TIMEOUT, 'timeout during call to BSHC');
            });
            if (postData) {
                req.write(postData);
            }
            req.end();
        });
    };
    AbstractBshcClient.prototype.handleError = function (observer, errorType, errorDetails) {
        this.logger.error('error during call to BSHC: ', errorDetails);
        try {
            if (errorDetails instanceof Error) {
                observer.error(new bshb_error_1.BshbError('error during call to BSHC: ', errorType, errorDetails));
            }
            else if (typeof errorDetails === 'string') {
                observer.error(new bshb_error_1.BshbError(errorDetails, errorType));
            }
            else {
                observer.error(new bshb_error_1.BshbError('error during call to BSHC', errorType));
            }
        }
        finally {
            observer.complete();
        }
    };
    AbstractBshcClient.PAIR_PORT = 8443;
    AbstractBshcClient.DEFAULT_TIMEOUT = 3000;
    return AbstractBshcClient;
}());
exports.AbstractBshcClient = AbstractBshcClient;
